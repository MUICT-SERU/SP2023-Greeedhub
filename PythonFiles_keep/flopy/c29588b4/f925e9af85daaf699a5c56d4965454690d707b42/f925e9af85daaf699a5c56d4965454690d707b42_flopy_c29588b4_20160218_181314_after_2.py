"""
mfstr module.  Contains the ModflowStr class. Note that the user can access
the ModflowStr class as `flopy.modflow.ModflowStr`.

Additional information for this MODFLOW package can be found at the `Online
MODFLOW Guide
<http://water.usgs.gov/ogw/modflow/MODFLOW-2005-Guide/str.htm>`_.

"""
import sys
import numpy as np
from ..pakbase import Package
from ..utils.util_list import MfList
from ..utils import Util3d, read_fixed_var

class ModflowLak(Package):
    """
    MODFLOW Lake Package Class.

    Parameters
    ----------
    model : model object
        The model object (of type :class:`flopy.modflow.mf.Modflow`) to which
        this package will be added.

    options : list of strings
        Package options. (default is None).
    extension : string
        Filename extension (default is 'str')
    unitnumber : int
        File unit number (default is 118).

    Methods
    -------

    See Also
    --------

    Notes
    -----
    Parameters are not supported in FloPy.

    Examples
    --------

    >>> import flopy
    >>> m = flopy.modflow.Modflow()
    >>> lak = {}
    >>> lak[0] = [[2, 3, 4, 15.6, 1050., -4]]  #this lake boundary will be
    >>>                                        #applied to all stress periods
    >>> lak = flopy.modflow.ModflowLak(m, stress_period_data=strd)

    """

    def __init__(self, model, dtype=None, nlakes=1, ipakcb=0, theta=-1.,
                 nssitr=0, sscncr=0.0, stages=1., stage_range=None,
                 iunit_tab=None, threeD_data = None,
                 stress_period_data=None, sill_data=None,
                 flux_data=None,
                 extension='lak', unitnumber=119, options=None, **kwargs):
        """
        Package constructor.

        """
        # Call parent init to set self.parent, extension, name and unit number
        Package.__init__(self, model, extension, 'LAK', unitnumber)
        self.heading = '# LAK for MODFLOW, generated by Flopy.'
        self.url = 'lak.htm'

        if options is None:
            options = []
        self.options = options
        self.nlakes = nlakes
        if ipakcb != 0:
            self.ipakcb = 53
        else:
            self.ipakcb = 0  # 0: no cell by cell terms are written
        self.theta = theta
        self.nssitr = nssitr
        self.sscncr = sscncr
        if isinstance(stages, float):
            stages = np.array(self.nlakes, dtype=np.float) * stages
        elif isinstance(stages, list):
            stages = np.array(stages)
        if stages.shape[0] != nlakes:
            err = 'stages shape should be ({}) but is only ({}).'.format(nlakes,
                                                                         stages.shape[0])
            raise Exception(err)
        self.stages = stages
        if stage_range is None:
            stage_range = np.ones((nlakes, 2), dtype=np.float)
            stage_range[:, 0] = -10000.
            stage_range[:, 1] = 10000.
        else:
            if isinstance(stage_range, list):
                stage_range = np.array(stage_range)
            elif isinstance(stage_range, float):
                err = 'stage_range should be a list or array of size ({}, 2)'.format(nlakes)
                raise Exception(err)
        if model.dis.steady[0]:
            if stage_range.shape != (nlakes, 2):
                err = 'stages shape should be ({},2) but is only {}.'.format(nlakes,
                                                                             stages_range.shape)
                raise Exception(err)
        self.stage_range = stage_range

        for option in self.options:
            if 'TABLEINPUT' in option.upper():
                if iunit_tab is None:
                    err = "iunit_tab must be specified if 'TABLEIPUT' option specified"
                    raise Exception(err)
                if isinstance(iunit_tab, int):
                    iunit_tab = np.array([iunit_tab])
                elif isinstance(iunit_tab, list):
                    iunit_tab = np.array(iunit_tab)
                if iunit_tab.shape[0] != nlakes:
                    err = 'iunit_tab must be a list or array with ({}) entries'.format(nlakes)
                    raise Exception(err)
        self.iunit_tab = iunit_tab

        if threeD_data is None and stress_period_data is None:
            err = 'threeD_data or stress_period_data must be specified'
            raise Exception(err)

        if stress_period_data is not None:
            if not isinstance(stress_period_data, dict):
                err = 'stress_period_data must be a dictionary'
                raise Exception(err)
        if threeD_data is not None:
            if not isinstance(threeD_data, dict):
                err = 'threeD_data must be a dictionary'
                raise Exception(err)
        if flux_data is not None:
            if not isinstance(flux_data, dict):
                err = 'flux_data must be a dictionary'
                raise Exception(err)

        nrow, ncol, nlay, nper = model.get_nrow_ncol_nlay_nper()

        # not tested yet
        if stress_period_data is None:
            stress_period_data = {}
            npers = list(threeD_data.keys())
            for ipers in npers:
                lakarr = Util3d(model, (nlay, nrow, ncol), np.int,
                                threeD_data[ipers][0], name='LAKARR',
                                locat=self.unit_number[0]).array
                bdlknc = Util3d(model, (nlay, nrow, ncol), np.float32,
                                threeD_data[ipers][0], name='BDLKNC',
                                locat=self.unit_number[0]).array
                lakeids, stress_period_data[iper] = \
                    ModflowLak.transform3Dtorecarray(lakarr, bdlknc)

        if dtype is not None:
            self.dtype = dtype
        else:
            self.dtype = self.get_default_dtype(structured=self.parent.structured)

        self.stress_period_data = MfList(self, stress_period_data)
        self.sill_data = sill_data
        self.flux_data = flux_data

        self.parent.add_package(self)

        return

    @staticmethod
    def get_empty(ncells=0, aux_names=None, structured=True):
        # get an empty recarray that correponds to dtype
        dtype = ModflowLak.get_default_dtype(structured=structured)
        if aux_names is not None:
            dtype = Package.add_to_dtype(dtype, aux_names, np.float32)
        d = np.zeros((ncells, len(dtype)), dtype=dtype)
        d[:, :] = -1.0E+10
        return np.core.records.fromarrays(d.transpose(), dtype=dtype)

    @staticmethod
    def get_default_dtype(structured=True):
        if structured:
            dtype = np.dtype([("k", np.int), ("i", np.int), ("j", np.int),
                              ("lake", np.int), ("leakance", np.float32)])
        else:
            dtype = np.dtype([("node", np.int), ("lake", np.int),
                              ("leakance", np.float32)])

        return dtype

    def ncells(self):
        # Return the  maximum number of cells that have a stream
        # (developed for MT3DMS SSM package)
        return self.mxacts

    def write_file(self):
        """
        Write the package file.

        Returns
        -------
        None

        """
        f = open(self.fn_path, 'w')
        # dataset 0
        self.heading = '# {} for {}, generated by Flopy.'.format(self.name,
                                                                 self.parent.version)
        f.write('{0}\n'.format(self.heading))

        # close the str file
        f.close()

    @staticmethod
    def transform3Dtorecarray(lakarr, bdlknc):
        """

        Parameters
        ----------
        lakarr :
        bdlknc :

        Returns
        -------

        """
        # get a list of unique lake numbers
        lakeids = np.unique(lakarr).tolist()
        lakecnt = np.bincount(lakarr.flatten())
        # remove non-lake ids from the list
        lakeids = [(i, j) for i, j in zip(lakeids, lakecnt) if i != 0]

        # create stress_period_data for this stress period
        ncells = 0
        for lake, icnt in lakeids:
            ncells += icnt
        spd = ModflowLak.get_empty(ncells=ncells)

        ipos = 0
        for lake, icnt in lakeids:
            idx = np.where(lakarr == lake)
            for j in range(icnt):
                k, i, j = idx[0][j], idx[1][j], idx[2][j]
                spd['k'][ipos] = k
                spd['j'][ipos] = i
                spd['i'][ipos] = j
                spd['lake'][ipos] = lake
                spd['leakance'][ipos] = bdlknc[k, i, j]
                ipos += 1
        return lakeids, spd


    @staticmethod
    def load(f, model, nper=None, ext_unit_dict=None):
        """
        Load an existing package.

        Parameters
        ----------
        f : filename or file handle
            File to load.
        model : model object
            The model object (of type :class:`flopy.modflow.mf.Modflow`) to
            which this package will be added.
        nper : int
            The number of stress periods.  If nper is None, then nper will be
            obtained from the model object. (default is None).
        ext_unit_dict : dictionary, optional
            If the arrays in the file are specified using EXTERNAL,
            or older style array control records, then `f` should be a file
            handle.  In this case ext_unit_dict is required, which can be
            constructed using the function
            :class:`flopy.utils.mfreadnam.parsenamefile`.

        Returns
        -------
        str : ModflowStr object
            ModflowStr object.

        Examples
        --------

        >>> import flopy
        >>> m = flopy.modflow.Modflow()
        >>> lak = flopy.modflow.ModflowStr.load('test.lak', m)

        """

        if model.verbose:
            sys.stdout.write('loading lak package file...\n')

        if not hasattr(f, 'read'):
            filename = f
            f = open(filename, 'r')

        # dataset 0 -- header
        while True:
            line = f.readline()
            if line[0] != '#':
                break

        options = []
        tabdata = False
        if 'TABLEINPUT' in line.upper():
            if model.verbose:
                print("   reading lak dataset 1a")
            options.append('TABLEINPUT')
            tabdata = True
            line = f.readline()
        
        # read dataset 1b
        if model.verbose:
            print("   reading lak dataset 1b")
        t = line.strip().split()
        nlakes = int(t[0])
        ipakcb = 0
        try:
            ipakcb1 = int(t[1])
            if ipakcb1 != 0:
                ipakcb = 53
                model.add_pop_key_list(ipakcb1)
        except:
            pass

        # read dataset 2
        line = f.readline().rstrip()
        if model.array_free_format:
            t = line.split()
        else:
            t = read_fixed_var(line, ncol=4)
        theta = float(t[0])
        nssitr, sscncr = 0, 0.
        try:
            nssitr = int(t[1])
        except:
            pass
        try:
            sscncr = float(t[2])
        except:
            pass
        surfdep = 0.
        if theta < 0.:
            surfdep = float(t[3])


        if nper is None:
            nrow, ncol, nlay, nper = model.get_nrow_ncol_nlay_nper()

        if model.verbose:
            print("   reading lak dataset 3")
        stages = []
        stage_range = []
        iunit_tab = []
        for lake in range(nlakes):
            line = f.readline().rstrip()
            if model.array_free_format:
                t = line.split()
            else:
                t = read_fixed_var(line, ncol=4)
            stages.append(t[0])
            ipos = 1
            if model.dis.steady[0]:
                stage_range.append((t[ipos], t[ipos+1]))
                ipos += 2
            if tabdata:
                iunit_tab.append(t[ipos])


        stress_period_data = {}
        sill_data = {}
        flux_data = {}
        for iper in range(nper):
            if model.verbose:
                print("   reading lak dataset 4 - for stress period {}".format(iper+1))
            line = f.readline().rstrip()
            if model.array_free_format:
                t = line.split()
            else:
                t = read_fixed_var(line, ncol=3)
            itmp, itmp1, lwrt = int(t[0]), int(t[1]), int(t[2])

            if itmp > 0:
                if model.verbose:
                    print("   reading lak dataset 5 - for stress period {}".format(iper+1))
                lakarr = Util3d.load(f, model, (nlay, nrow, ncol), np.int,
                                     'LKARR', ext_unit_dict).array
                if model.verbose:
                    print("   reading lak dataset 6 - for stress period {}".format(iper+1))
                bdlknc = Util3d.load(f, model, (nlay, nrow, ncol), np.float32,
                                     'BDLKNC', ext_unit_dict).array

                # convert three-dimensional data to a list
                lakeids, current = ModflowLak.transform3Dtorecarray(lakarr, bdlknc)

                if model.verbose:
                    print("   reading lak dataset 7 - for stress period {}".format(iper+1))
                line = f.readline().rstrip()
                t = line.split()
                nslms = int(t[0])
                ds8 = []
                if nslms > 0:
                    if model.verbose:
                        print("   reading lak dataset 8 - for stress period {}".format(iper+1))
                    for i in range(nslms):
                        line = f.readline().rstrip()
                        if model.array_free_format:
                            t = line.split()
                        else:
                            ic = line[0:10]
                            t = read_fixed_var(line, ncol=ic+1)
                        ic = int(t[0])
                        isub = []
                        for j in range(ic):
                            isub.append(int(t[j+1]))
                        line = f.readline().rstrip()
                        if model.array_free_format:
                            t = line.split()
                        else:
                            ic = line[0:10]
                            t = read_fixed_var(line, ncol=ic-1)
                        silvt = []
                        for j in range(ic-1):
                            silvt.append(float(t[j]))
                        ds8.append((t, silvt))
            if itmp1 >= 0:
                if model.verbose:
                    print("   reading lak dataset 9 - for stress period {}".format(iper+1))
                ds9 = {}
                for n in range(nlakes):
                    line = f.readline().rstrip()
                    if model.array_free_format:
                        t = line.split()
                    else:
                        t = read_fixed_var(line, ncol=6)
                    tds = []
                    tds.append(float(t[0]))
                    tds.append(float(t[1]))
                    tds.append(float(t[2]))
                    tds.append(float(t[3]))
                    if model.dis.steady[iper]:
                        if iper == 0:
                            tds.append(stage_range[n][0])
                            tds.append(stage_range[n][1])
                        else:
                            tds.append(float(t[4]))
                            tds.append(float(t[5]))
                    else:
                        tds.append(0.)
                        tds.append(0.)
                    ds9[n+1] = tds

            if itmp > 0:
                stress_period_data[iper] = current
                sill_data[iper] = ds8
            if itmp1 >= 0:
                flux_data[iper] = ds9


        lakpak = ModflowLak(model, options=options, nlakee=nlakes,
                            ipakcb=ipakcb, theta=theta, nssitr=nssitr,
                            sscncr=sscncr, stages=stages,
                            stage_range=stage_range, iunit_tab=iunit_tab,
                            stress_period_data=stress_period_data,
                            sill_data=sill_data, flux_data=flux_data)
        return lakpak
