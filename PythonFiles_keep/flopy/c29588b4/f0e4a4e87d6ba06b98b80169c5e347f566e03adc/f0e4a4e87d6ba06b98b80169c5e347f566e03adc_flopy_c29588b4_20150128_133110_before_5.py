import copy
import numpy as np
# from numpy import ones, zeros, empty
from flopy.mbase import Package
from flopy.utils import util_2d, util_3d


class ModflowSwi2(Package):
    'Salt Water Intrusion (SWI2) package class'

    def __init__(self, model, nsrf=1, istrat=1, nobs=0, iswizt=55, iswibd=56, iswiobs=0, fsssopt=False, adaptive=False,
                 nsolver=1, iprsol=0, mutsol=3, \
                 solver2params={'mxiter': 100, 'iter1': 20, 'npcond': 1, 'zclose': 1e-3, 'rclose': 1e-4, 'relax': 1.0,
                                'nbpol': 2, 'damp': 1.0, 'dampt': 1.0},
                 toeslope=0.05, tipslope=0.05, alpha=None, beta=0.1, nadptmx=1, nadptmn=1, adptfct=1.0,
                 nu=0.025, zeta=[], ssz=[], isource=0,
                 obsnam=[], obslrc=[],
                 extension=['swi2', 'zta', 'swb'], unit_number=29,
                 npln=None):
        name = ['SWI2', 'DATA(BINARY)', 'DATA(BINARY)']
        units = [unit_number, iswizt, iswibd]
        extra = ['', 'REPLACE', 'REPLACE']
        if nobs > 0:
            extension = name.append('zobs')
            name = name.append('DATA')
            units = units.append(iswiobs)
            extra = extra.append('')

        Package.__init__(self, model, extension=extension, name=name, unit_number=units,
                         extra=extra)  # Call ancestor's init to set self.parent, extension, name and unit number

        nrow, ncol, nlay, nper = self.parent.nrow_ncol_nlay_nper
        self.heading = '# Salt Water Intrusion (SWI2) package file for MODFLOW-2005, generated by Flopy.'
        #
        self.fsssopt, self.adaptive = fsssopt, adaptive
        #
        if npln is not None:
            print 'npln keyword is deprecated. use the nsrf keyword'
            nsrf = npln

        self.nsrf, self.istrat, self.nobs, self.iswizt, self.iswibd, self.iswiobs = nsrf, istrat, nobs, \
                                                                                    iswizt, iswibd, iswiobs
        #
        self.nsolver, self.iprsol, self.mutsol = nsolver, iprsol, mutsol
        #
        self.solver2params = solver2params
        #
        self.toeslope, self.tipslope, self.alpha, self.beta = toeslope, tipslope, alpha, beta
        self.nadptmx, self.nadptmn, self.adptfct = nadptmx, nadptmn, adptfct
        # Create arrays so that they have the correct size
        if self.istrat == 1:
            self.nu = util_2d(model, (self.nsrf + 1,), np.float32, nu, name='nu')
        else:
            self.nu = util_2d(model, (self.nsrf + 2,), np.float32, nu, name='nu')
        self.zeta = []
        for i in range(self.nsrf):
            self.zeta.append(util_3d(model, (nlay, nrow, ncol), np.float32, zeta[i], name='zeta_' + str(i + 1)))
        self.ssz = util_3d(model, (nlay, nrow, ncol), np.float32, ssz, name='ssz')
        self.isource = util_3d(model, (nlay, nrow, ncol), np.int, isource, name='isource')
        #
        self.obsnam = obsnam
        self.obslrc = obslrc
        #
        self.parent.add_package(self)

    def __repr__(self):
        return 'Salt Water Intrusion (SWI2) package class'

    def write_file(self):
        nrow, ncol, nlay, nper = self.parent.nrow_ncol_nlay_nper
        # Open file for writing
        f_swi = open(self.fn_path, 'w')
        # First line: heading
        f_swi.write('{}\n'.format(self.heading))  # Writing heading not allowed in SWI???
        # --write dataset 1
        f_swi.write('#--Dataset 1\n')
        f_swi.write(
            '{:10d}{:10d}{:10d}{:10d}{:10d}{:10d}'.format(self.nsrf, self.istrat, self.nobs, self.iswizt, self.iswibd,
                                                          self.iswiobs))

        if self.fsssopt is True:
            f_swi.write('    FSSSOPT')
        if self.adaptive is True:
            f_swi.write('   ADAPTIVE')
        f_swi.write('\n')
        #--write dataset 2a
        f_swi.write('#--Dataset 2a\n')
        f_swi.write('{:10d}{:10d}{:10d}\n'.format(self.nsolver, self.iprsol, self.mutsol))
        #--write dataset 2b
        if self.nsolver == 2:
            f_swi.write('#--Dataset 2b\n')
            f_swi.write('{:10d}'.format(self.solver2params['mxiter']))
            f_swi.write('{:10d}'.format(self.solver2params['iter1']))
            f_swi.write('{:10d}'.format(self.solver2params['npcond']))
            f_swi.write('%14.6e'.format(self.solver2params['zclose']))
            f_swi.write('%14.6e'.format(self.solver2params['rclose']))
            f_swi.write('%14.6e'.format(self.solver2params['relax']))
            f_swi.write('{:10d}'.format(self.solver2params['nbpol']))
            f_swi.write('{:14.6g}'.format(self.solver2params['damp']))
            f_swi.write('{:14.6g}\n'.format(self.solver2params['dampt']))
        #--write dataset 3a
        f_swi.write('#--Dataset 3a\n')
        f_swi.write('{:14.6g}{:14.6g}'.format(self.toeslope, self.tipslope))
        if self.alpha is not None:
            f_swi.write('{:14.6g}{:14.6g}'.format(self.alpha, self.beta))
        f_swi.write('\n')
        #--write dataset 3b
        if self.adaptive is True:
            f_swi.write('#--Dataset 3b\n')
            f_swi.write('{:10d}{:10d}{:14.6g}\n'.format(self.nadptmx, self.nadptmn, self.adptfct))
        #--write dataset 4
        f_swi.write('#--Dataset 4\n')
        f_swi.write(self.nu.get_file_entry())
        #--write dataset 5
        f_swi.write('#--Dataset 5\n')
        for isur in range(self.nsrf):
            for ilay in range(nlay):
                f_swi.write(self.zeta[isur][ilay].get_file_entry())
        #--write dataset 6
        f_swi.write('#--Dataset 6\n')
        f_swi.write(self.ssz.get_file_entry())
        #--write dataset 7
        f_swi.write('#--Dataset 7\n')
        f_swi.write(self.isource.get_file_entry())
        #--write dataset 8
        if self.nobs > 0:
            f_swi.write('#--Dataset 8\n')
            for i in range(self.nobs):
                #f_swi.write(self.obsnam[i] + 3 * '%10i' % self.obslrc + '\n')
                f_swi.write('{} {:10d}{:10d}{:10d}\n'.format(self.obsnam[i], self.obslrc))
        #--close swi2 file
        f_swi.close()


    @staticmethod
    def load(f, model, ext_unit_dict=None):
        """
        Load an existing package.

        Parameters
        ----------
        f : filename or file handle
            File to load.
        model : model object
            The model object (of type :class:`flopy.modflow.mf.Modflow`) to
            which this package will be added.
        ext_unit_dict : dictionary, optional
            If the arrays in the file are specified using EXTERNAL,
            or older style array control records, then `f` should be a file
            handle.  In this case ext_unit_dict is required, which can be
            constructed using the function
            :class:`flopy.utils.mfreadnam.parsenamefile`.

        Returns
        -------
        swi2 : ModflowSwi2 object

        Examples
        --------

        >>> import flopy
        >>> m = flopy.modflow.Modflow()
        >>> lpf = flopy.modflow.ModflowSwi2.load('test.swi2', m)

        """
        if type(f) is not file:
            filename = f
            f = open(filename, 'r')
        # dataset 0 -- header
        while True:
            line = f.readline()
            if line[0] != '#':
                break
        # determine problem dimensions
        nrow, ncol, nlay, nper = model.get_nrow_ncol_nlay_nper()

        # --read dataset 1
        t = line.strip().split()
        nsrf = int(t[0])
        istrat = int(t[1])
        nobs = int(t[2])
        if int(t[3]) > 0:
            iswizt = 55
        if int(t[4]) > 0:
            iswibd = 56
        iswiobs = int(t[5])
        fsssopt = False
        if 'fsssopt' in line.lower():
            fsssopt = True
        adaptive = False
        if 'adaptive' in line.lower():
            adaptive = True

        #--read dataset 2a
        while True:
            line = f.readline()
            if line[0] != '#':
                break
        t = line.strip().split()
        nsolver = int(t[0])
        iprsol = int(t[1])
        mutsol = int(t[2])

        #--read dataset 2b
        solver2params = {}
        if nsolver == 2:
            while True:
                line = f.readline()
                if line[0] != '#':
                    break
            t = line.strip().split()
            solver2params['mxiter'] = int(t[0])
            solver2params['iter1'] = int(t[1])
            solver2params['npcond'] = int(t[2])
            solver2params['zclose'] = float(t[3])
            solver2params['rclose'] = float(t[4])
            solver2params['relax'] = float(t[5])
            solver2params['nbpol'] = int(t[6])
            solver2params['damp'] = float(t[7])
            solver2params['dampt'] = float(t[8])

        #--read dataset 3a
        while True:
            line = f.readline()
            if line[0] != '#':
                break
        t = line.strip().split()
        toeslope = float(t[0])
        tipslope = float(t[1])
        alpha = None
        beta = 0.1
        if len(t) > 2:
            try:
                alpha = float(t[2])
                beta = float(t[3])
            except:
                pass

        #--read dataset 3b
        nadptmx, nadptmn, adptfct = None, None, None
        if adaptive:
            while True:
                line = f.readline()
                if line[0] != '#':
                    break
            t = line.strip().split()
            nadptmx = int(t[0])
            nadptmn = int(t[1])
            adptfct = float(t[3])

        #--read dataset 4
        print '   loading nu...'
        if istrat == 1:
            nnu = nsrf + 1
        else:
            nnu = nsrf + 2
        while True:
            ipos = f.tell()
            line = f.readline()
            if line[0] != '#':
                f.seek(ipos)
                break
        nu = util_2d.load(f, model, (1, nnu), np.float32, 'nu',
                          ext_unit_dict)
        nu = nu.array.reshape((nnu))

        #--read dataset 5
        print '   loading initial zeta surfaces...'
        while True:
            ipos = f.tell()
            line = f.readline()
            if line[0] != '#':
                f.seek(ipos)
                break
        zeta = []
        for n in xrange(nsrf):
            ctxt = 'zeta_surf{:02d}'.format(n+1)
            z = util_3d.load(f, model, (nlay, nrow, ncol), np.float32,
                             ctxt, ext_unit_dict)
            zeta.append(copy.deepcopy(z))

        #--read dataset 6
        print '   loading initial ssz...'
        while True:
            ipos = f.tell()
            line = f.readline()
            if line[0] != '#':
                f.seek(ipos)
                break
        ssz = util_3d.load(f, model, (nlay, nrow, ncol), np.float32,
                           'ssz', ext_unit_dict)

        #--read dataset 7
        print '   loading initial isource...'
        while True:
            ipos = f.tell()
            line = f.readline()
            if line[0] != '#':
                f.seek(ipos)
                break
        isource = util_3d.load(f, model, (nlay, nrow, ncol), np.int,
                               'isource', ext_unit_dict)

        #--read dataset 8
        obsname = []
        obslrc = []
        if nobs > 0:
            print '   loading observation locations...'
            while True:
                line = f.readline()
                if line[0] != '#':
                    break
            for i in range(nobs):
                if i > 0:
                    line = f.readline()
                t = line.strip().split()
                obsname.append(t[0])
                kk = int(t[1])
                ii = int(t[2])
                jj = int(t[3])
                obslrc.append([kk, ii, jj])

        #--create swi2 instance
        swi2 = ModflowSwi2(model, nsrf=nsrf, istrat=istrat, nobs=nobs, iswizt=iswizt, iswibd=iswibd,
                           iswiobs=iswiobs, fsssopt=fsssopt, adaptive=adaptive,
                           nsolver=nsolver, iprsol=iprsol, mutsol=mutsol, solver2params=solver2params,
                           toeslope=toeslope, tipslope=tipslope, alpha=alpha, beta=beta,
                           nadptmx=nadptmx, nadptmn=nadptmn, adptfct=adptfct,
                           nu=nu, zeta=zeta, ssz=ssz, isource=isource,
                           obsnam=obsname, obslrc=obslrc)
        #--return swi2 instance
        return swi2
