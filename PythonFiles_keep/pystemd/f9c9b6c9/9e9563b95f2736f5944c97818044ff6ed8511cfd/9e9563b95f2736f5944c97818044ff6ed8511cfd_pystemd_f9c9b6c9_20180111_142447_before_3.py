#
# Copyright (c) 2017-present, Facebook, Inc.
# All rights reserved.
#
# This source code is licensed under the BSD-style license found in the
# LICENSE file in the root directory of this source tree. An additional grant
# of patent rights can be found in the PATENTS file in the same directory.
#
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import os
import select
import sys
import uuid

import pystemd

from pystemd.dbuslib import DBus, DBusMachine
from pystemd.systemd1 import Manager as SDManager, Unit


def get_fno(obj):
    """
    Try to get the best fileno of a obj:
        * If the obj is a integer, it return that integer.
        * If the obj has a fileno method, it return that function call.
    """

    if isinstance(obj, int):
        return obj
    elif hasattr(obj, 'fileno') and callable(getattr(obj, 'fileno')):
        return obj.fileno()

    raise TypeError("Expected int or fileobject with fileno method")


def run(cmd,
        name=None,
        user=None,
        user_mode=os.getuid() != 0,
        nice=None,
        env=None,
        extra=None,
        cwd=None,
        machine=None,
        wait=False,
        remain_after_exit=False,
        stdin=None, stdout=None, stderr=None):
    """
    pystemd.run imitates systemd-run, but with a pythonic feel to it.

    Options:

        cmd: Array with the command to execute (absolute path only)
        name: Name of the unit, if not provided autogenerated.
        user: Username to execute the command, defaults to current user.
        user_mode: Equivalent to running `systemd-run --user`. Defaults to True
            if current user id not root (uid = 0).
        nice: Nice level to run the command.
        env: A dict with environmental variables.
        extra: If you know what you are doing, you can pass extra configuration
            settings to the start_transient_unit method.
        machine: Machine name to execute the command, by default we connect to
            the host's dbus.
        wait: wait for command completition before returning control, defaults
            to False.
        remain_after_exit: If True, the transient unit will remain after cmd
            has finish, also if true, this methods will return
            pystemd.systemd1.Unit object. defaults to False and this method
            returns None and the unit will be gone as soon as is done.
        stdin: Specify a file descriptor for stdin, by default this is `None`
            and your unit will not have a stdin, you can specify it as
            `sys.stdin.fileno()`, or as a regular numer, e.g. `0`.
        stdout: Specify a file descriptor for stdout, by default this is `None`
            and your unit will not have a stdout, you can specify it as
            `sys.stdout.fileno()`, or `open('/tmp/out', 'w').fileno()`, or a
            regular number, e.g. `1`.
        stderr: Specify a file descriptor for stderr, by default this is `None`
            and your unit will not have a stderr, you can specify it as
            `sys.stderr.fileno()`, or `open('/tmp/err', 'w').fileno()`, or a
            regular number, e.g. `2`.


    Usage examples (all run as root):

    1.- executes a ``/bin/sleep 42` in the background.

    ```
    >>> import pystemd.run
    >>> pystemd.run([b'/bin/sleep', b'42'])
    ```

    2.- executes `/bin/sleep 42` but returns the units

    ```
    >>> import pystemd.run
    >>> unit = pystemd.run([b'/bin/sleep', b'42'], remain_after_exit=True)
    >>> unit
    <pystemd.systemd1.unit.Unit at 0x7f8c460695c0>
    >>> unit.Service.MainPID
    66244
    >>> # ... waiting 42 seconds later
    >>> unit.Service.MainPID
    0
    ```

    3.- executing `/bin/sleep 42` as other user

    ```
    >>> import pystemd.run
    >>> unit = pystemd.run([b'/bin/sleep', b'42'], remain_after_exit=True,
        user=b'aleivag'
    )
    ```

    4.- Multiple things: Executing `/bin/env`, on a machine named `miniarch`,
     watching the output of the command.

    ```
    >>> import pystemd.run, sys
    >>> pystemd.run(
        [b'/bin/env'],
        machine=b'miniarch',
        nice=3,
        stdout=sys.stdout.fileno(),
        env={b'SUPER_SECRET_PASSW': b'1234'}
        )
    LANG=en_US.UTF-8
    PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin
    INVOCATION_ID=d7abcffb71ba419cbac448baa00cb495
    SUPER_SECRET_PASSW=1234

    ```
    """
    def bus_factory():
        if machine:
            return DBusMachine(machine)
        else:
            return DBus(user_mode=user_mode)

    if name is None:
        _uuid = uuid.uuid4().hex
        name = 'pystemd{}.service'.format(_uuid).encode()

    unit_properties = {
        b'Description': b'pystemd: ' + name,
        b'ExecStart': [(cmd[0], cmd, False)],
        b'RemainAfterExit': remain_after_exit,
        b'WorkingDirectory': cwd,
        b'User': user,
        b'Nice': nice,
    }

    # pipe redirection
    unit_properties.update({
        b'StandardInputFileDescriptor': get_fno(stdin) if stdin else stdin,
        b'StandardOutputFileDescriptor': get_fno(stdout) if stdout else stdout,
        b'StandardErrorFileDescriptor': get_fno(stderr) if stderr else stderr,
    })

    if env:
        unit_properties[b'Environment'] = [
            b'%s=%s' % (key, value)
            for key, value in env.items()
        ]

    unit_properties.update(extra or {})
    unit_properties = {
        k: v for k, v in unit_properties.items() if v is not None}
    with bus_factory() as monbus, \
            bus_factory() as bus, \
            SDManager(bus=bus) as manager,\
            pystemd.DBus.Manager(bus=monbus) as monitor:

        unit = Unit(name, bus=bus, _autoload=True)
        if wait:
            mstr = (
                "type='signal',"
                "sender='org.freedesktop.systemd1',"
                "path='{}',"
                "interface='org.freedesktop.DBus.Properties',"
                "member='PropertiesChanged'"
            ).format(unit.path.decode()).encode()
            monitor.Monitoring.BecomeMonitor([mstr], 0)
            monitor_fd = monbus.get_fd()

        manager.Manager.StartTransientUnit(name, b'fail', unit_properties)

        while wait:
            _in, _, _ = select.select([monitor_fd], [], [], 0.5)
            if _in:
                m = monbus.process()
                if m.is_empty():
                    continue

                m.process_reply(False)
                if m.get_path() == unit.path:
                    if m.body[1].get(b'ActiveState') == b'inactive':
                        break
            elif user_mode and unit.Service.MainPID == 0:
                # on usermode the subcribe to events does not work that well
                # this is a temporaly hack. you can always not wait on usermode.
                break

        if remain_after_exit:
            unit.load()
            unit.bus_context = bus_factory
            return unit


# do pystemd.run callable.
run.__module__ = sys.modules[__name__]
sys.modules[__name__] = run
