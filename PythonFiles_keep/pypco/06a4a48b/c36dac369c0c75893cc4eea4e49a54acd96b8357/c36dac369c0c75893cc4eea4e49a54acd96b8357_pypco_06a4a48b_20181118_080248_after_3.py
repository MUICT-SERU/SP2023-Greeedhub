"""PyPCO Generator.

Dynamically generates PyPCO endpoint and model classes.

Usage:
    pypco_generator.py: --doc-url=<doc-url> --endpoint-path=<endpoint-path> --model-path=<model-path> [--verbose]
    pypco_generator.py: (-h | --help)

Options:
    -h --help                        Show this screen.
    --doc-url=<doc-url>              The URL to PCO documentation graph (and version) for the desired app.
    --endpoint-path=<endpoint-path>  Path to a folder into which the generated endpoint file should be placed.
    --model-path=<model-path>        Path to a folder into which the generated model file should be placed.
    --verbose                        Enable verbose output.
"""

import os
import logging
import base64
import json
import requests
import jinja2
from docopt import docopt

# Template for endpoint classes
#region
ENDPOINT_TEMPLATE = """\"\"\"PCO {{ app }} endpoints.

Generated by pypco_generator tool. Manual changes not recommended.
\"\"\"

#pylint: disable=C0304,R0903,C0111,C0321

from .base_endpoint import BaseEndpoint

# The the {{ app }} app
class {{ app }}Endpoint(BaseEndpoint): pass

# All {{ app }} endpoints
{%- for endpoint in endpoints %}
class {{ endpoint }}({{ app }}Endpoint): pass
{%- endfor %}

"""
#endregion

# Template for model classes
#region
MODEL_TEMPlATE=""""""
#endregion

def generate(
        doc_url,
        endpoint_path,
        model_path
    ):
    '''Generate PyPCO endpoints and models.

    Args:
        app_id (str): An application ID with full PCO API access.
        app_secret (str): Secret corresponding to given app id.
        doc_url (str): The URL of PCO documentation for which code should be generated.
        endpoint_path (str): Output path for the generated endpoint file.
        model_path (str): Output path for the generated model file.
    '''

    # Determine what app we are building for
    #region
    logging.debug("Finding app we're building for...")
    logging.debug("Doc URL is: {}".format(doc_url))

    url_split = doc_url.split('/')
    app = url_split[url_split.index('v2') - 1]

    logging.info("Building endpoints and models for: {}".format(app.upper()))
    #endregion

    # Get the docs
    #region
    logging.debug("Accessing {} documentation graph.".format(app.upper()))

    response = requests.get(doc_url)

    if response.status_code != 200:
        logging.debug("Raw response error: {}".format(response.text))

    doc_json = json.loads(response.text)
    #endregion

    # Get the endpoints for the app
    #region

    outbound_edges = doc_json['data']['relationships']['entry']['data']['relationships']['outbound_edges']['data']
    outbound_edges = [edge['attributes']['name'] for edge in outbound_edges]

    endpoints = _convert_organization_list(outbound_edges)

    logging.debug("PyPCO friendly endpoints are: {}".format(endpoints))

    #endregion

    # Get model classes for the app
    vertices = doc_json['data']['relationships']['vertices']['data']
    logging.debug("Found {} vertices for {}.".format(len(vertices), app.upper()))

    models = []

    for vertex in vertices:
        if vertex['id'] == 'organization':
            continue

        response = requests.get("{}/vertices/{}".format(doc_url, vertex['id']))

        if response.status_code != 200:
            logging.debug("Raw response error: {}".format(response.text))

        vertex_json = json.loads(response.text)

        path = vertex_json['data']['attributes']['path'].split('/')

        models.append(
            {
                'name': vertex['attributes']['name'],
                'endpoint': path[path.index('v2') + 1]
            }
        )

    logging.debug("Results of model resolution: {}".format(models))

    # Output endpoint class
    #region

    endpoint_vars = {
        'app': _underscore_to_camelcase(app, repl_char='-'),
        'endpoints': endpoints
    }

    logging.debug("Vars for Endpoint template: {}".format(endpoint_vars))

    endpoint_template = jinja2.Template(ENDPOINT_TEMPLATE)

    endpoint_output = endpoint_template.render(endpoint_vars)

    with open("{}{}{}.py".format(endpoint_path, os.sep, app.replace('-', '_')), 'w') as endpoint_output_file:
        endpoint_output_file.write(endpoint_output)

    #endregion

    # Output model class


def _convert_organization_list(organization_output):
    '''Convert organization endpoint to PyPCO-friendly.

    Args:
        organization_output (dict): Dict of "links" property values from the organization endpoint.

    Returns:
        endpoints (list): The list of PyPCO-friendly endpoint names.
    '''

    output = []

    for endpoint in organization_output:
        if endpoint != 'self':

            output.append(_underscore_to_camelcase(endpoint))

    return output

def _underscore_to_camelcase(underscore_str, repl_char = '_'):
    '''Convert underscore style string to camel case.

    Args:
        underscore_str (str): A string in underscore style
        repl_char (str): The indicating text that should be transformed to camel case.
                         default is '_'

    Returns:
        string (str): The string converted to camel case.
    '''

    string = list(underscore_str)
    string[0] = string[0].upper()

    try:
        while True:
            under_ndx = string.index(repl_char)
            del string[under_ndx]
            string[under_ndx] = string[under_ndx].upper()
    except ValueError:
        pass

    return ''.join(string)

if __name__ == '__main__':
    arguments = docopt(__doc__)

    logging.basicConfig(
        format = '%(levelname)s >> %(message)s',
        level = logging.DEBUG if arguments['--verbose'] else logging.INFO
    )

    generate(
        arguments['--doc-url'],
        arguments['--endpoint-path'],
        arguments['--model-path']
    )
