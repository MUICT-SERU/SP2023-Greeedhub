""" Options and configs. """

from itertools import product, islice
import collections
import warnings
from copy import deepcopy
import numpy as np

from .. import Config, Sampler, SequenceSampler

class KV:
    """ Class for value and alias

    Parameters
    ----------
    value : obj

    alias : obj
        if None alias will be equal to value.
    """
    def __init__(self, value, alias=None):
        if isinstance(value, KV):
            self.value = value.value
            self.alias = value.alias
        else:
            self.value = value
            if alias is None:
                self.alias = self._get_name(value)
            else:
                self.alias = alias

    def __repr__(self):
        return 'KV(' + str(self.alias) + ': ' + str(self.value) + ')'

    def _get_name(self, value):
        if hasattr(value, '__name__'):
            name = value.__name__
        else:
            name = str(value)
        return name

class Option:
    """ Class for single-parameter option. There is an algebra of options (see :class:`~.Domain` operations)
    Result is a `Domain`.

    Parameters
    ----------
    parameter : KV or obj

    values : list of KV or lis of obj
    """
    def __init__(self, parameter, values, shuffle=False):
        self.parameter = KV(parameter)
        if isinstance(values, SequenceSampler):
            self._values = values.array
            self.values = values
        elif isinstance(values, Sampler):
            self._values = None
            self.values = values
        else:
            self._values = [KV(value) for value in values]
            self.values = SequenceSampler(self._values, shuffle)

    def __matmul__(self, other):
        if self._values is None or other._values is None:
            domain = self * other
        elif len(self._values) == len(other._values):
            domain = Domain()
            for item in zip(self._values, other._values):
                domain += Option(self.parameter, [item[0]]) * Option(other.parameter, [item[1]])
        return domain

    def __mul__(self, other):
        return Domain(self) * Domain(other)

    def __add__(self, other):
        return Domain(self) + Domain(other)

    def __repr__(self):
        if self._values is None:
            return 'Option({}, {})'.format(self.parameter.alias, self.values)
        else:
            return 'Option({}, {})'.format(self.parameter.alias, [item.alias for item in self._values])

    def sample(self, size, squeeze=True):
        return [ConfigAlias([[self.parameter, self.values.sample(1, squeeze)]]) for _ in range(size)]

    def iterator(self, brute_force=False, n_iters=None, squeeze=True):
        for value in self.values.iterator(brute_force, n_iters, squeeze):
            yield ConfigAlias([[self.parameter, value]])

    def gen_configs(self, n_items=1):
        """ Returns Configs created from the option """
        domain = Domain(self)
        return domain.gen_configs(n_items)


class ConfigAlias:
    """ Class for config and alias which is represenation of config where all keys and values are str.

    Parameters
    ----------
    config : list of (key, value)
        keys and values are KV or objects
    """
    def __init__(self, config=None):
        _config = []
        if config is not None:
            for item in config:
                key = item[0] if isinstance(item[0], KV) else KV(item[0])
                value = item[1] if isinstance(item[1], KV) else KV(item[1])
                _config.append((key, value))
        self._config = _config

    def alias(self, as_string=False, delim='-'):
        """ Returns alias. """
        config_alias = {item[0].alias: item[1].alias for item in self._config}
        if as_string:
            config_alias = collections.OrderedDict(sorted(config_alias.items()))
            config_alias = delim.join([str(key)+'_'+str(value) for key, value in config_alias.items()])
        return config_alias

    def config(self):
        """ Returns values. """
        return Config({item[0].value: item[1].value for item in self._config})

    def __repr__(self):
        return 'ConfigAlias(' + str(self.alias()) + ')'

    def __add__(self, other):
        config = ConfigAlias()
        config._config = deepcopy(self._config) + deepcopy(other._config)
        return config

class Domain:
    """ Class for domain of parameters. `Domain` is a list of list of Options. Each list of Options
    will produce configs as an Cartesian multiplications of Option values.

    Parameters
    ----------
    domain : Option, Domain or list of lists of Options


    **Operations with Domains**

    #. sum by `+`: Concatenate list of Configs generated by Domains

    #. multiplication by `*`: Cartesian multiplications of Options in Domain.
       For example, if `domain1 = Option('a': [1, 2])` and
       `domain1 = Option('b': [3, 4])` then `domain1 * domain2` will have both options and generate 4 configs:
       `{a: 1, b: 3}`, `{a: 1, b: 4}`, `{a: 2, b: 3}`, `{a: 2, b: 4}`.
    """
    def __init__(self, domain=None, **kwargs):
        if isinstance(domain, Option):
            self.domain = [[domain]]
        elif isinstance(domain, Domain):
            self.domain = domain.domain
        elif isinstance(domain, dict):
            self.domain = self._dict_to_domain(domain)
        else:
            self.domain = domain

        self.update_func = None
        self.each = None

        self._iterator = None

        self._brute_force = False
        self.n_iters = None
        self.n_reps = 1
        self.repeat_each = 100

        if len(kwargs) > 0:
            self.domain.append(self._dict_to_domain(kwargs))

    def _dict_to_domain(self, domain):
        _domain = []
        for key, value in domain.items():
            _domain.append(Option(key, value))
        return [_domain]

    def __mul__(self, other):
        if self.domain is None:
            result = other
        elif isinstance(other, Domain):
            if other.domain is None:
                result = self
            else:
                res = list(product(self.domain, other.domain))
                res = [item[0] + item[1] for item in res]
            result = Domain(res)
        elif isinstance(other, Option):
            result = self * Domain(other)
        else:
            raise TypeError('Arguments must be Domains or Options')
        return result

    def __add__(self, other):
        if self.domain is None:
            result = other
        elif isinstance(other, Option):
            result = self + Domain(other)
        elif other.domain is None:
            result = self
        elif isinstance(other, Domain):
            if other.domain is None:
                result = self
            else:
                result = Domain(self.domain + other.domain)
        return result

    def __repr__(self):
        return 'Domain(' + str(self.domain) + ')'

    def __getitem__(self, index):
        return Domain([self.domain[index]])

    def __eq__(self, other):
        return self.domain() == other.domain()

    def sample(self, size):
        cubes = np.random.choice(np.array(self.domain + [None])[:-1], size=size)
        return [sum([option.sample(1)[0] for option in cube], ConfigAlias()) for cube in cubes]

    def samples_iterator(self, n_iters=None):
        if n_iters is None:
            while True:
                yield self.sample(1)[0]
        else:
            for _ in range(n_iters):
                yield self.sample(1)[0]

    def brute_force(self, n_iters=None):
        iteration = 0
        while True:
            for cube in self.domain:
                _seq_options = [option for option in cube if option._values is not None]
                _sampler_options = [option for option in cube if option._values is None]
                for item in product(*[option.iterator(brute_force=True) for option in _seq_options]):
                    item = sum(item, ConfigAlias())
                    for _option in _sampler_options:
                        item += _option.sample(1)[0]
                    yield item
                    iteration += 1
                    if n_iters is not None and iteration == n_iters:
                        break
                else:
                    continue
                break
            if n_iters is None or iteration == n_iters:
                break

    def iterator(self, brute_force=False, n_iters=None, n_reps=1, repeat_each=100):
        """ Iterator to get all possible values from Sampler.

        Parameters
        ----------
        brute_force : bool
            if True, iterator will return all possible values from sampler, else values will be
            independently sampled.
        n_iters : int or None

        n_reps : int

        repeat_each : int
        """
        generator = self.brute_force(n_iters) if brute_force else self.samples_iterator(n_iters)
        if n_reps == 1:
            yield from generator
        else:
            if n_iters is not None or repeat_each is None:
                results = list(generator)
                for repetition in range(n_reps):
                    for res in results:
                        yield res + ConfigAlias([('repetition', repetition)])
            else:
                results = list(islice(generator, repeat_each))
                while len(results) > 0:
                    for repetition in range(n_reps):
                        for res in results:
                            yield res + ConfigAlias([('repetition', repetition)])
                    results = list(islice(generator, repeat_each))

    def set_iterator(self, brute_force=False, n_iters=None, n_reps=1, repeat_each=100):
        self._iterator = None
        self._brute_force = brute_force # Do we need it?
        self.n_iters = n_iters
        self.n_reps = n_reps
        self.repeat_each = repeat_each

        size = self.size
        if self._brute_force and self.n_iters is not None and self.n_iters > size:
            warnings.warn("n_iters is greater then number of elements in Domain: {} > {}".format(self.n_iters, size),
                          RuntimeWarning)

    @property
    def size(self):
        if self.n_iters is not None:
            return self.n_reps * self.n_iters
        elif self.n_iters is None and self._brute_force:
            size = 0
            for cube in self.domain:
                _seq_options = [option for option in cube if option._values is not None]
                opt_sizes = [len(list(option.iterator(brute_force=True))) for option in _seq_options]
                size += np.product(opt_sizes)
            return size * self.n_reps
        else:
            return None

    def set_update(self, function=None, each=None):
        if function is not None:
            self.update_domain = function
        self.each = each

    def __iter__(self):
        if self._iterator is None:
            self._iterator = self.iterator(self._brute_force, self.n_iters, self.n_reps, self.repeat_each)
        return self._iterator

    def __next__(self):
        if self._iterator is None:
            self._iterator = self.iterator(self._brute_force, self.n_iters, self.n_reps, self.repeat_each)
        return next(self._iterator)

    def update_domain(self, *args, **kwargs):
        _ = args, kwargs
        return None

    def update_config(self, *args, **kwargs):
        _ = args, kwargs
        return None
