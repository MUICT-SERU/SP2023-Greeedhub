from collections.abc import Sequence, Set
from typing import Any, Iterable, Mapping, Tuple, TypeVar, Union

from pydantic import BaseModel

T = TypeVar("T")


def dict_to_flatdict(
    dct: Mapping[T, Any], _parent: Tuple[T, ...] = None
) -> Mapping[Tuple[T, ...], Any]:
    """Converts a (nested) dictionary to a flattened representation.

    Each key of the flat dict will be a CompoundKey tuple containing the "chain of keys"
    for the corresponding value.

    Args:
        - dct (dict): The dictionary to flatten
        - _parent (Tuple, optional): The current parent for recursion

    Returns:
        - A flattened dict of the same type as dct
    """
    typ = type(dct)
    items = []
    parent = _parent or tuple()

    for k, v in dct.items():
        k_parent = tuple(parent + (k,))
        if isinstance(v, dict):
            items.extend(dict_to_flatdict(v, _parent=k_parent).items())
        else:
            items.append((k_parent, v))
    return typ(items)


def flatdict_to_dict(dct: Mapping[Tuple[T, ...], Any]) -> Mapping[T, Any]:
    """Converts a flattened dictionary back to a nested dictionary.

    Args:
        - dct (dict): The dictionary to be nested. Each key should be a tuple of keys
            as generated by `dict_to_flatdict`

    Returns
        - A nested dict of the same type as dct
    """
    typ = type(dct)
    result = typ()
    for key_tuple, value in dct.items():
        current_dict = result
        for prefix_key in key_tuple[:-1]:
            # Build nested dictionaries up for the current key tuple
            current_dict = current_dict.setdefault(prefix_key, typ())
        # Set the value
        current_dict[key_tuple[-1]] = value

    return result


def ensure_iterable(obj: Union[T, Iterable[T]]) -> Iterable[T]:
    if isinstance(obj, Sequence) or isinstance(obj, Set):
        return obj
    return [obj]
