
import sys
import numpy as np
from flopy.pakbase import Package


class ModflowHob(Package):
    '''
    Head Observation package class

    Parameters
    ----------
    nh : int
        Number of head observations
    mobs : int
        Number of multilayer head observations
    maxm : int
        Maximum number of layers for multilayer heads
    iuhobsv : int
        unit number where output is saved
    hobdry : float
        Value of the simulated equivalent written to the observation output file
        when the observation is omitted because a cell is dry
    tomulth : float
        Time step multiplier for head observations. The product of tomulth and
        toffset must produce a time value in units consistent with other model
        input. tomulth can be dimensionless or can be used to convert the units
        of toffset to the time unit used in the simulation.
    obsnam : string list of length nh
        Observation name
    layer : int list of length nh
        is the layer index of the cell in which the head observation is located.
        If layer is less than zero, hydraulic heads from multiple layers are
        combined to calculate a simulated value. The number of layers equals the
        absolute value of layer, or |layer|.
    row : int list of length nh
        row index for the observation
    column : int list of length nh
        column index of the observation
    irefsp : int of length nh
        Stress period to which the observation time is referenced. The reference
        point is the beginning of the specified stress period. If the value of
        irefsp is negative, there are observations at |irefsp| times.
    toffset : float list of length nh
        Fractional offset between time steps
    roff : float list of length nh
        Fractional offset from center of cell in Y direction (between rows)
    coff : float list of length nh
        Fractional offset from center of cell in X direction (between columns)
    hob : float list of length nh
        Observed value
    fromlay : int of length nh
        Layer index where observation begins
    tolay : int of length nh
        Layer index where observation end
    mlay : int list of length (maxm,mobs)
        Layer numbers for multilayer observations
    pr : float list of length(maxm,mobs)
        Fractional value for each layer of multilayer observations
    itt : int
        Flag that identifies whether head or head changes are used as observations
        itt = 1 --> heads
        itt = 2 --> initial value is head and subsequent changes in head
    extension : string
        Filename extension (default is ['hob','obh'])
    unitnumber : int
        File unit number (default is [39, 139])


    Attributes
    ----------

    Methods
    -------

    See Also
    --------

    Notes

    '''

    def __init__(self, model, nh=0, mobs=0, maxm=0, iuhobsv=139, hobdry=0,
                 tomulth=1.0, obsnam=[], layer=[], row=[], column=[],
                 irefsp=[], toffset=[], roff=[], coff=[], hob=[],
                 fromlay=[], tolay=[], mlay=[], pr=[], itt=[],
                 extension=['hob', 'obh'], unitnumber=[39, 139]):
        # tomulth=1, obsnam=None, layer=None, row=None, column=None,
        # irefsp=None, toffset=None, roff=None, coff=None, hob=None,
        # fromlay=None,tolay=None,mlay=None, pr=None, itt=1,
        """
        Package constructor
        """
        name = ['HOB', 'DATA']
        Package.__init__(self, model, extension, name, unitnumber)

        self.url = 'hob.htm'
        self.heading = '# {} package for '.format(self.name[0]) + \
                       ' {}, '.format(model.version_types[model.version]) + \
                       'generated by Flopy.'
        self.nh = nh
        self.mobs = mobs
        self.maxm = maxm
        self.iuhobsv = iuhobsv
        self.hobdry = hobdry
        self.tomulth = tomulth
        self.obsnam = obsnam
        self.layer = layer
        self.row = row
        self.column = column
        self.irefsp = irefsp
        self.toffset = toffset
        self.roff = roff
        self.coff = coff
        self.hob = hob
        self.fromlay = fromlay
        self.tolay = tolay
        self.mlay = mlay  # swm: not needed?
        self.pr = pr
        self.itt = itt

        # -create empty arrays of the correct size
        # self.obsnam = np.empty((self.nh), dtype='str')
        self.layer = np.zeros((self.nh), dtype='int32')
        self.row = np.zeros((self.nh), dtype='int32')
        self.column = np.zeros((self.nh), dtype='int32')
        self.irefsp = np.zeros((self.nh), dtype='int32')
        self.toffset = np.zeros((self.nh), dtype='float32')
        self.roff = np.zeros((self.nh), dtype='float32')
        self.coff = np.zeros((self.nh), dtype='float32')
        self.hob = np.zeros((self.nh), dtype='float32')
        self.fromlay = np.zeros((self.nh), dtype='int32')
        self.tolay = np.zeros((self.nh), dtype='int32')
        self.mlay = np.zeros((self.nh), dtype='int32')  # swm: not needed?
        self.pr = np.zeros((self.nh, self.maxm), dtype='float32')
        self.itt = np.ones((self.nh), dtype='int32')

        # -assign values to arrays
        # self.obsnam[:] = np.empty((self.nh), dtype='str')
        # self.layer[:] = np.zeros((self.nh), dtype='int32')
        # self.row[:] = np.zeros((self.nh), dtype='int32')
        # self.column[:] = np.zeros((self.nh), dtype='int32')
        # self.irefsp[:] = np.zeros((self.nh), dtype='int32')
        # self.toffset[:] = np.zeros((self.nh), dtype='float32')
        # self.roff[:] = np.zeros((self.nh), dtype='float32')
        # self.coff[:] = np.zeros((self.nh), dtype='float32')
        # self.hob[:] = np.zeros((self.nh), dtype='float32')
        # self.fromlay[:] = np.zeros((self.nh), dtype='int32')
        # self.tolay[:] = np.zeros((self.nh), dtype='int32')
        # self.mlay[:] = np.zeros((self.nh), dtype='int32') #swm: not needed?
        # self.pr[:,:] = np.zeros((self.nh, self.maxm), dtype='float32')
        # self.itt[:] = np.zeros((self.nh), dtype='int32')
        # self.itt[:] = np.ones((self.nh), dtype='int32')

        self.obsnam[:] = obsnam
        # self.obsnam[:] = np.array(obsnam, dtype='str')
        self.layer[:] = layer
        self.row[:] = row
        self.column[:] = column
        self.irefsp[:] = irefsp
        self.toffset[:] = toffset
        self.roff[:] = roff
        self.coff[:] = coff
        self.hob[:] = hob
        self.fromlay[:] = fromlay
        self.tolay[:] = tolay
        # self.mlay[:] = mlay #swm: not needed?
        self.pr[:, :] = pr
        self.itt[:] = itt

        # putting in some more checks here


        # add checks for input compliance (obsnam length, etc.)
        self.parent.add_package(self)

    def write_file(self):
        """
        Write the package file

        Returns
        -------
        None

        """
        # open file for writing
        f = open(self.fn_path, 'w')

        # write dataset 0
        f.write('{}\n'.format(self.heading))

        # write dataset 1
        f.write('{:10d}'.format(self.nh))
        f.write('{:10d}'.format(self.mobs))
        f.write('{:10d}'.format(self.maxm))
        f.write('{:10d}'.format(self.iuhobsv))
        f.write('{:10.4g}\n'.format(self.hobdry))

        # write dataset 2
        f.write('{:10d}\n'.format(self.tomulth))  # check format

        # write datasets 3-6
        i = 0
        while i < self.nh:
            multilayer = False
            if self.fromlay[i] < self.tolay[i]:
                multilayer = True
            if multilayer:  # check if multilayer obs
                self.layer[i] = self.fromlay[i] - self.tolay[i] - 1

            # write dataset 3
            f.write('{}'.format(self.obsnam[i]))
            f.write('{:10d}'.format(self.layer[i]))
            f.write('{:10d}'.format(self.row[i]))
            f.write('{:10d}'.format(self.column[i]))
            f.write('{:10d}'.format(self.irefsp[i]))
            f.write('{:10.4g}'.format(self.toffset[i]))
            f.write('{:10.4g}'.format(self.roff[i]))
            f.write('{:10.4g}'.format(self.coff[i]))
            f.write('{:10.4g}\n'.format(self.hob[i]))

            # write dataset 4 if multilayer obs
            if multilayer:
                for j in range(self.fromlay[i], self.tolay[i] + 1):
                    f.write('{:10d}'.format(j))
                    f.write('{:10.4g}\n'.format(self.pr[i, j-1]))

            # write datasets 5 & 6. Index loop variable
            if self.irefsp[i] < 0:
                # data set 5
                f.write('{:10d}\n'.format(self.itt[i]))
                # data set 6
                for j in range(abs(self.irefsp[i])):
                    f.write('{}'.format(self.obsnam[i]))
                    f.write('{:10d}'.format(abs(self.irefsp[i])))
                    f.write('{:10.4g}'.format(self.toffset[i]))
                    f.write('{:10.4g}\n'.format(self.hob[i]))
                    i += 1
            else:
                i += 1

        f.close()

        # # swm: BEGIN hack for writing standard file
        # sfname = self.fn_path  # swm:hack
        # sfname += '_ins'  # swm: hack
        # # write header
        # f_ins = open(sfname, 'w')  # swm: hack for standard file
        # f_ins.write('jif @\n')  # swm: hack for standard file
        # f_ins.write(
        #     'StandardFile 1 1 %s\n' % (self.nh))  # swm: hack for standard file
        # for i in range(0, self.nh):
        #     f_ins.write(
        #         '{}\n'.format(self.obsnam[i]))  # swm: hack for standard file
        # # swm: END hack for writing standard file

        return

    @staticmethod
    def load(f, model, ext_unit_dict=None, check=True):
        """
        Load an existing package.

        Parameters
        ----------
        f : filename or file handle
            File to load.
        model : model object
            The model object (of type :class:`flopy.modflow.mf.Modflow`) to
            which this package will be added.
        ext_unit_dict : dictionary, optional
            If the arrays in the file are specified using EXTERNAL,
            or older style array control records, then `f` should be a file
            handle.  In this case ext_unit_dict is required, which can be
            constructed using the function
            :class:`flopy.utils.mfreadnam.parsenamefile`.
        check : boolean
            Check package data for common errors. (default True)

        Returns
        -------
        hob : ModflowHob object
            ModflowHob object.

        Examples
        --------

        >>> import flopy
        >>> m = flopy.modflow.Modflow()
        >>> hobs = flopy.modflow.ModflowHob.load('test.hob', m)

        """

        if model.verbose:
            sys.stdout.write('loading hob package file...\n')

        if not hasattr(f, 'read'):
            filename = f
            f = open(filename, 'r')
        # dataset 0 -- header
        while True:
            line = f.readline()
            if line[0] != '#':
                break

        # read dataset 1
        t = line.strip().split()
        nh = int(t[0])
        mobs = int(t[1])
        maxm = int(t[2])
        iuhobsv = int(t[3])
        hobdry = float(t[4])

        # read dataset 2
        line = f.readline()
        t = line.strip().split()
        tomulth = int(t[0])

        # create observation lists
        obsnam = []
        layer = []
        fromlay = []
        tolay = []
        row = []
        column = []
        irefsp = []
        toffset = []
        roff = []
        coff = []
        hob = []
        mobs = []
        pr = []
        itt = []
        ds6 = []


        # read datasets 3-6
        for i in range(nh):
            # read dataset 3
            line = f.readline()
            t = line.strip().split()
            obsnam.append(t[0])
            tlayer = int(t[1])
            layer.append(tlayer - 1)
            row.append(int(t[2]) - 1)
            column.append(int(t[3]) - 1)
            tirefsp = int(t[4])
            irefsp.append(tirefsp)
            toffset.append(float(t[5]))
            roff.append(float(t[6]))
            coff.append(float(t[7]))
            hob.append(float(t[8]))

            # read dataset 4 if multilayer obs
            if tlayer < 0:
                minlay = 999
                maxlay = -999
                line = f.readline()
                d4 = line.strip().split()
                tmobs = []
                tpr = []
                for j in range(0, abs(tlayer), 2):
                    k = int(d4[j]) - 1
                    if k < minlay:
                        minlay = k
                    if k > maxlay:
                        maxlay = k
                    tmobs.append(k)
                    tpr.append(float(d4[j+1]))
            else:
                minlay = tlayer - 1
                maxlay = tlayer - 1
                tmobs = None
                tpr = None
            fromlay.append(minlay)
            tolay.append(maxlay)
            mobs.append(tmobs)
            pr.append(tpr)

            # read datasets 5 & 6. Index loop variable
            if tirefsp < 0:
                # read data set 5
                line = f.readline()
                d5 = line.strip().split()
                titt = int(d5[0])
                # dataset 6
                tds6 = []
                for j in range(abs(tirefsp)):
                    line = f.readline()
                    t = line.strip().split()
                    tds6.append([t[0], int(t[1]), float(t[2]), float(t[3])])
            else:
                titt = None
                tds6 = None
            itt.append(titt)
            ds6.append(tds6)

        # close the file
        f.close()

        return
