from operator import attrgetter
import numpy as np

import collections

# using solution from http://stackoverflow.com/questions/3487434/overriding-append-method-after-inheriting-from-a-python-list
# to create a list type that can be restricted to a certain type - to support leaf-list.
class TypedList(collections.MutableSequence):
  def __init__(self, allowed_types, *args):
    self.allowed_types = type
    self.list = list()
    self.extend(list(args))

  def check(self, v):
    if not isinstance(self, allowed_types):
      raise TypeError, v

  def __len__(self): return len(self.list)

  def __getitem__(self,i): return self.list[i]

  def __delitem__(self,i): del self.list[i]

  def __setitem__(self, i, v):
    self.check(v)
    self.list[i] = v

  def insert(self, i, v):
    self.check(v)
    self.list.insert(i,v)

  def __str__(self):
    return str(self.list)

class yc_condiments__bar_condiments(object):
  """
   This class was auto-generated by the PythonClass plugin for PYANG
   from YANG module test - based on the path /bar/condiments.
   Each member element of the container is represented as a class
   variable - with a specific YANG type.
  """
  __ketchup = str()
  __other = TypedList(str)

  def _get_ketchup(self):
    return self.__ketchup
  def _set_ketchup(self,v):
      if not isinstance(v, str):
        raise TypeError("ketchup must be of type str")
      self.__ketchup = v

  def _get_other(self):
    return self.__other
  def _set_other(self,v):
      if not isinstance(v, TypedList):
        raise TypeError("other must be of type TypedList")
      self.__other = v
  ketchup = property(_get_ketchup, _set_ketchup)
  other = property(_get_other, _set_other)

class yc_bar__bar(object):
  """
   This class was auto-generated by the PythonClass plugin for PYANG
   from YANG module test - based on the path /bar.
   Each member element of the container is represented as a class
   variable - with a specific YANG type.
  """
  __fish = bool()
  __chips = bool(False)
  __elephant = np.uint8()
  __condiments = yc_condiments__bar_condiments()

  def _get_fish(self):
    return self.__fish
  def _set_fish(self,v):
      if not isinstance(v, bool):
        raise TypeError("fish must be of type bool")
      self.__fish = v

  def _get_chips(self):
    return self.__chips
  def _set_chips(self,v):
      if not isinstance(v, bool):
        raise TypeError("chips must be of type bool")
      self.__chips = v

  def _get_elephant(self):
    return self.__elephant
  def _set_elephant(self,v):
      if not isinstance(v, np.uint8):
        raise TypeError("elephant must be of type np.uint8")
      self.__elephant = v

  def _get_condiments(self):
    return self.__condiments
  def _set_condiments(self,v):
      if not isinstance(v, yc_condiments__bar_condiments):
        raise TypeError("condiments must be of type yc_condiments__bar_condiments")
      self.__condiments = v
  fish = property(_get_fish, _set_fish)
  chips = property(_get_chips, _set_chips)
  elephant = property(_get_elephant, _set_elephant)
  condiments = property(_get_condiments, _set_condiments)

class yc_fishhat__state_fishhat(object):
  """
   This class was auto-generated by the PythonClass plugin for PYANG
   from YANG module test - based on the path /state/fishhat.
   Each member element of the container is represented as a class
   variable - with a specific YANG type.
  """
  _hats_for_fish = np.uint8(10)
  hats_for_fish = property(attrgetter("_hats_for_fish"))

class yc_state__state(object):
  """
   This class was auto-generated by the PythonClass plugin for PYANG
   from YANG module test - based on the path /state.
   Each member element of the container is represented as a class
   variable - with a specific YANG type.
  """
  __fishhat = yc_fishhat__state_fishhat()

  def _get_fishhat(self):
    return self.__fishhat
  def _set_fishhat(self,v):
      if not isinstance(v, yc_fishhat__state_fishhat):
        raise TypeError("fishhat must be of type yc_fishhat__state_fishhat")
      self.__fishhat = v
  fishhat = property(_get_fishhat, _set_fishhat)

class test(object):
  """
   This class was auto-generated by the PythonClass plugin for PYANG
   from YANG module test - based on the path /.
   Each member element of the container is represented as a class
   variable - with a specific YANG type.
  """
  __bar = yc_bar__bar()
  __state = yc_state__state()

  def _get_bar(self):
    return self.__bar
  def _set_bar(self,v):
      if not isinstance(v, yc_bar__bar):
        raise TypeError("bar must be of type yc_bar__bar")
      self.__bar = v

  def _get_state(self):
    return self.__state
  def _set_state(self,v):
      if not isinstance(v, yc_state__state):
        raise TypeError("state must be of type yc_state__state")
      self.__state = v
  bar = property(_get_bar, _set_bar)
  state = property(_get_state, _set_state)

