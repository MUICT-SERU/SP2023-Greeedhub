""" Options and configs. """

from itertools import product
from functools import reduce # Valid in Python 2.6+, required in Python 3
import operator
import collections
from copy import deepcopy
import numpy as np

from .. import Config, Sampler, SequenceSampler

class KV:
    """ Class for value and alias

    Parameters
    ----------
    value : obj

    alias : obj
        if None alias will be equal to value.
    """
    def __init__(self, value, alias=None):
        if isinstance(value, KV):
            self.value = value.value
            self.alias = value.alias
        else:
            self.value = value
            if alias is None:
                self.alias = self._get_name(value)
            else:
                self.alias = alias

    def __repr__(self):
        return 'KV(' + str(self.alias) + ': ' + str(self.value) + ')'

    def _get_name(self, value):
        if hasattr(value, '__name__'):
            name = value.__name__
        else:
            name = str(value)
        return name

class Option:
    """ Class for single-parameter option. There is an algebra of options (see :class:`~.Grid` operations)
    Result is a `Grid`.

    Parameters
    ----------
    parameter : KV or obj

    values : list of KV or lis of obj
    """
    def __init__(self, parameter, values, shuffle=False):
        self.parameter = KV(parameter)
        if isinstance(values, Sampler):
            self._values = None
            self.values = values
        else:
            self._values = [KV(value) for value in values]
            self.values = SequenceSampler(self._values, shuffle)

    def __matmul__(self, other):
        if self._values is None or other._values is None:
            grid = self * other
        elif len(self._values) == len(other._values):
            grid = Grid()
            for item in zip(self._values, other._values):
                grid += Option(self.parameter, [item[0]]) * Option(other.parameter, [item[1]])
        return grid

    def __mul__(self, other):
        return Grid(self) * Grid(other)

    def __add__(self, other):
        return Grid(self) + Grid(other)

    def __repr__(self):
        if self._values is None:
            return 'Option({}, {})'.format(self.parameter.alias, self.values)
        else:
            return 'Option({}, {})'.format(self.parameter.alias, [item.alias for item in self._values])

    def sample(self, size, squeeze=True):
        return [ConfigAlias([[self.parameter, self.values.sample(1, squeeze)]]) for _ in range(size)]

    def iterator(self, squeeze=True):
        for value in self.values.iterator(squeeze):
            yield ConfigAlias([[self.parameter, value]])

    def gen_configs(self, n_items=1):
        """ Returns Configs created from the option """
        grid = Grid(self)
        return grid.gen_configs(n_items)

class ConfigAlias:
    """ Class for config and alias which is represenation of config where all keys and values are str.

    Parameters
    ----------
    config : list of (key, value)
        keys and values are KV or objects
    """
    def __init__(self, config=None):
        _config = []
        if config is not None:
            for item in config:
                key = item[0] if isinstance(item[0], KV) else KV(item[0])
                value = item[1] if isinstance(item[1], KV) else KV(item[1])
                _config.append((key, value))
        self._config = _config

    def alias(self, as_string=False, delim='-'):
        """ Returns alias. """
        config_alias = {item[0].alias: item[1].alias for item in self._config}
        if as_string:
            config_alias = collections.OrderedDict(sorted(config_alias.items()))
            config_alias = delim.join([str(key)+'_'+str(value) for key, value in config_alias.items()])
        return config_alias

    def config(self):
        """ Returns values. """
        return Config({item[0].value: item[1].value for item in self._config})

    def __repr__(self):
        return 'ConfigAlias(' + str(self.alias()) + ')'

    def __add__(self, other):
        config = ConfigAlias()
        config._config = deepcopy(self._config) + deepcopy(other._config)
        return config

class Grid:
    """ Class for grid of parameters. `Grid` is a list of list of Options. Each list of Options
    will produce configs as an Cartesian multiplications of Option values.

    Parameters
    ----------
    grid : Option, Grid or list of lists of Options


    **Operations with Grids**

    #. sum by `+`: Concatenate list of Configs generated by Grids

    #. multiplication by `*`: Cartesian multiplications of Options in Grid.
       For example, if `grid1 = Option('a': [1, 2])` and
       `grid1 = Option('b': [3, 4])` then `grid1 * grid2` will have both options and generate 4 configs:
       `{a: 1, b: 3}`, `{a: 1, b: 4}`, `{a: 2, b: 3}`, `{a: 2, b: 4}`.
    """
    def __init__(self, grid=None, **kwargs):
        if isinstance(grid, Option):
            self.grid = [[grid]]
        elif isinstance(grid, Grid):
            self.grid = grid.grid
        elif isinstance(grid, dict):
            self.grid = self._dict_to_grid(grid)
        else:
            self.grid = grid

        if len(kwargs) > 0:
            self.grid.append(self._dict_to_grid(kwargs))

    def _dict_to_grid(self, grid):
        _grid = []
        for key, value in grid.items():
            _grid.append(Option(key, value))
        return [_grid]

    def __mul__(self, other):
        if self.grid is None:
            result = other
        elif isinstance(other, Grid):
            if other.grid is None:
                result = self
            else:
                res = list(product(self.grid, other.grid))
                res = [item[0] + item[1] for item in res]
            result = Grid(res)
        elif isinstance(other, Option):
            result = self * Grid([[other]])
        else:
            raise TypeError('Arguments must be Grids or Options')
        return result

    def __add__(self, other):
        if self.grid is None:
            result = other
        elif isinstance(other, Option):
            result = self + Grid(other)
        elif other.grid is None:
            result = self
        elif isinstance(other, Grid):
            if other.grid is None:
                result = self
            else:
                result = Grid(self.grid + other.grid)
        return result

    def __repr__(self):
        return 'Grid(' + str(self.alias()) + ')'

    def __getitem__(self, index):
        return Grid([self.grid[index]])

    def __eq__(self, other):
        return self.grid() == other.grid()
    
    def sample(self, size):
        cubes = np.random.choice(np.array(self.grid + [None])[:-1], size=size)
        return [ConfigAlias([(option.parameter, KV(option.values.sample(1)[0, 0])) for option in cube]) for cube in cubes]
    
    def iterator(self, n_reps):
        for cube in self.grid:
            _seq_options = [option for option in cube if option._values is not None]
            _sampler_options = [option for option in cube if option._values is None]
            res = []

            for item in product(*[option.iterator() for option in _seq_options]):
                item = sum(item, ConfigAlias())
                for _option in _sampler_options:
                    item += _option.sample(1)[0]
                yield item
                

    def description(self):
        """ Return description of used aliases.
        Returns
        -------
        dict
        """
        options = [option for grid_item in self.grid for option in grid_item]
        descr = dict()
        for option in options:
            values = {value.alias: value.value for value in option.values}
            if option.parameter.alias not in descr:
                descr[option.parameter.alias] = {'name': option.parameter.value, 'values': values}
            else:
                descr[option.parameter.alias]['values'].update(values)
        return descr

    def gen_configs(self, n_items=1, include_index=False):
        """ Generate Configs from grid

        Parameters
        ----------
        n_items : int
            how much configs return on each iteration
        """
        i = 0
        for item in self.grid:
            keys = [option.parameter for option in item]
            values = [option.values for option in item]
            if n_items == 1:
                for parameters in product(*values):
                    i += 1
                    config = ConfigAlias(list(zip(keys, parameters)))
                    yield (i, config) if include_index else config
            else:
                res = []
                for parameters in product(*values):
                    if len(res) < n_items:
                        config = ConfigAlias(list(zip(keys, parameters)))
                        res.append((i, config) if include_index else config)
                    else:
                        yield res
                        config = ConfigAlias(list(zip(keys, parameters)))
                        res = [(i, config) if include_index else config]
                yield res

    def subset(self, grid, by_alias=True):
        """ Get grid subset produces by another grid

        Parameters
        ----------
        grid : Grid

        by_alias : bool
            if True, perform subsetting by aliases, else by real values
        """
        results = []
        if isinstance(grid, (Config, dict)):
            slice_configs = [ConfigAlias(grid.items())]
        else:
            slice_configs = list(grid.gen_configs())
        for full_config in self.gen_configs():
            for partial_config in slice_configs:
                if by_alias:
                    small = partial_config.alias()
                    large = full_config.alias()
                else:
                    small = partial_config.config().flatten()
                    large = full_config.config().flatten()
                if len(set(small.items()) - set(large.items())) == 0:
                    results.append(full_config)
        return results
