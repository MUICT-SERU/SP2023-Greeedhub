#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Jan 16 15:00:01 2019

@author: hab031
"""


__all__ = ["UnsupervisedSampler"]


import random
import numpy as np

from stellargraph.core.utils import is_real_iterable
from stellargraph.core.graph import StellarGraphBase
from stellargraph.data.explorer import UniformRandomWalk


class UnsupervisedSampler:
    """
        The UnsupervisedSampler is responsible for sampling walks (from a given instance of walker) 
        and returning positive and negative samples w.r.t. those walks on demand. 
        The positive samples are all the (target, context) pairs from the walks generated by walker. 
        Negative samples are contexts generated for each target based on a sampling strategy. 
        It requires at least a Stellargraph  and a walker instance. 
        The walker is the graph sampling strategy, such as uniform random walk, biased random walk etc. 
        Currently only uniform random walks are performed but this can be easily modified to accommodate other types of walks.

    """

    def __init__(
        self, G, walker=None, nodes=None, length=2, number_of_walks=1, seed=None
    ):

        """
           Initializing all the paramters for the class instance. 
           Args:
               G <StellarGraph>: A stellargraph with features.
               walker <UniformRandomWalk>: The only walking method supported for sampling is Uniform Random Walk.
               nodes <iterable of nodes from the graph>: if none provided, defaults to all nodes in the graph.
               length <int>: An integer value for the length of the walk. 
                   Minimum length is 2 since the samples are a pair of target,context so at least one hop is needed beyond the root node.
               number_of_walks <int>: Number of walks from each root node. 
                   Only used to calculate the number of batches in each epoch,
                   as we do not have a pregenerated sample list, we need to estimate given a batch_size, 
                   how many batches to generate in each epoch.  
               
        
        """
        if not isinstance(G, StellarGraphBase):
            raise ValueError(
                "({}) Graph must be a StellarGraph object.".format(type(self).__name__)
            )
        else:
            self.graph = G

        # walker
        if walker is not None:
            if not isinstance(
                walker, UniformRandomWalk
            ):  # only work with Uniform Random Walker at the moment
                raise TypeError(
                    "({}) Only Uniform Random Walks are possible".format(
                        type(self).__name__
                    )
                )
            else:
                self.walker = UniformRandomWalk(G)
        else:
            self.walker = UniformRandomWalk(G)

        if nodes is None:
            self.nodes = (
                G.nodes()
            )  # if no root nodes are provided for sampling defaulting to using all nodes as root nodes.
        elif not is_real_iterable(nodes):  # check whether the nodes provided are valid.
            raise ValueError("nodes parameter should be an iterableof node IDs.")
        else:
            self.nodes = nodes

        if (
            length < 2
        ):  # for a  sample pair need at least one neighbor beyond the root node.
            raise ValueError(
                "({}) For generating (target,context) samples, walk length has to be at least 2".format(
                    type(self).__name__
                )
            )
        else:
            self.length = length

        if number_of_walks < 1:
            raise ValueError(
                "({}) At least 1 walk from each head node has to be done".format(
                    type(self).__name__
                )
            )
        else:
            self.number_of_walks = number_of_walks

        self.seed = seed

    def generator(self, batch_size):

        """
        This method yields a batch_size of +/- samples when it is called. A positive even integer for batch_size must be provided.
        This method generates one walk at a time of a given length from each root node. 
        It exracts postive pairs from the walks and sample a negative pair for each positive
        one from a given sampling distribution. It returns the batch_size of postive and negative samples.
                    
         Args:
             batch_size: <int> number of samples to generate in each call of generator

        Returns:
            A tuple of lists: (target, context) pairs and their labels. 
        """

        self._check_parameter_values(batch_size)

        positive_pairs = list()
        negative_pairs = list()

        sample_counter = 0

        all_nodes = list(self.graph.nodes())

        # Use the sampling distribution as per node2vec
        degrees = self.graph.degree()
        sampling_distribution = [degrees[n] ** 0.75 for n in all_nodes]

        done = False
        while not done:
            for node in self.nodes:  # iterate over root nodes
                # Get 1 walk at a time. For now its assumed that its a uniform random walker
                walk = self.walker.run(
                    nodes=[node],  # root nodes
                    length=self.length,  # maximum length of a random walk
                    n=1,  # number of random walks per root node
                    seed=self.seed,
                )
                # (target,contect) pair sampling - GraphSAGE way
                target = walk[0][0]
                context_window = walk[0][1:]
                for context in context_window:
                    # Don't add self pairs
                    if context == target:
                        continue
                    else:
                        positive_pairs.append((target, context))
                        sample_counter += 1

                        # For each positive sample, add a negative sample.
                        random_sample = random.choices(
                            all_nodes, weights=sampling_distribution, k=1
                        )
                        negative_pairs.append((target, *random_sample))
                        sample_counter += 1

                        # If the batch_size number of samples are accumulated, yield.
                        if sample_counter == batch_size:
                            all_pairs = positive_pairs + negative_pairs
                            all_targets = [1] * len(positive_pairs) + [0] * len(
                                negative_pairs
                            )

                            positive_pairs.clear()
                            negative_pairs.clear()
                            sample_counter = 0

                            edge_ids_labels = list(zip(all_pairs, all_targets))
                            random.shuffle(edge_ids_labels)
                            edge_ids, edge_labels = zip(*edge_ids_labels)

                            yield edge_ids, edge_labels

    def _check_parameter_values(self, batch_size):
        """
        Checks that the parameter values are valid or raises ValueError exceptions with a message indicating the
        parameter (the first one encountered in the checks) with invalid value.

        Args:
            batch_size: <int> number of samples to generate in each call of generator
            
        """

        if (
            batch_size is None
        ):  # must provide a batch size since this is an indicator of how many samples to return
            raise ValueError(
                "({}) The batch_size must be provided to generate samples for each batch in the epoch".format(
                    type(self).__name__
                )
            )

        if type(batch_size) != int:  # must be an integer
            raise TypeError(
                "({}) The batch_size must be positive integer.".format(
                    type(self).__name__
                )
            )

        if batch_size < 1:  # must be greater than 0
            raise ValueError(
                "({}) The batch_size must be positive integer.".format(
                    type(self).__name__
                )
            )

        if (
            batch_size % 2 != 0
        ):  # should be even since we generate 1 negative sample for each positive one.
            raise ValueError(
                "({}) The batch_size must be an even integer since equal number of positive and negative samples are generated in each batch.".format(
                    type(self).__name__
                )
            )
